# Simple Neural Network Inference
# For running pre-trained models on embedded devices

# Network configuration
make var nn_input_size = 0
make var nn_hidden_size = 0
make var nn_output_size = 0

# Network weights (simplified - would be loaded from file)
make array nn_weights_ih size 100  # Input to hidden
make array nn_weights_ho size 100  # Hidden to output
make array nn_bias_h size 10       # Hidden bias
make array nn_bias_o size 10       # Output bias

# Activation buffers
make array nn_input size 10
make array nn_hidden size 10
make array nn_output size 10

# Initialize network
function nn_init(input_size, hidden_size, output_size) {
    nn_input_size = input_size
    nn_hidden_size = hidden_size
    nn_output_size = output_size
}

# Load weights (simplified)
function nn_load_weights(weights, size) {
    make var i = 0
    loop size times {
        nn_weights_ih[i] = weights[i]
        i = i + 1
    }
}

# ReLU activation
function nn_relu(x) {
    if x < 0 {
        return 0
    }
    return x
}

# Sigmoid activation
function nn_sigmoid(x) {
    # Approximation: 1 / (1 + exp(-x))
    # Simplified for embedded
    if x < -5 {
        return 0
    }
    if x > 5 {
        return 1
    }
    return 0.5 + x / 10
}

# Forward pass
function nn_forward(input, input_size) {
    # Copy input
    make var i = 0
    loop input_size times {
        nn_input[i] = input[i]
        i = i + 1
    }
    
    # Input to hidden layer
    make var h = 0
    loop nn_hidden_size times {
        make var sum = nn_bias_h[h]
        
        i = 0
        loop nn_input_size times {
            make var weight_idx = h * nn_input_size + i
            sum = sum + nn_input[i] * nn_weights_ih[weight_idx]
            i = i + 1
        }
        
        nn_hidden[h] = nn_relu(sum)
        h = h + 1
    }
    
    # Hidden to output layer
    make var o = 0
    loop nn_output_size times {
        make var sum = nn_bias_o[o]
        
        h = 0
        loop nn_hidden_size times {
            make var weight_idx = o * nn_hidden_size + h
            sum = sum + nn_hidden[h] * nn_weights_ho[weight_idx]
            h = h + 1
        }
        
        nn_output[o] = nn_sigmoid(sum)
        o = o + 1
    }
}

# Get output
function nn_get_output(index) {
    return nn_output[index]
}

# Get predicted class (argmax)
function nn_predict() {
    make var max_val = nn_output[0]
    make var max_idx = 0
    
    make var i = 1
    loop nn_output_size - 1 times {
        if nn_output[i] > max_val {
            max_val = nn_output[i]
            max_idx = i
        }
        i = i + 1
    }
    
    return max_idx
}

# Get confidence
function nn_confidence() {
    make var max_val = nn_output[0]
    
    make var i = 1
    loop nn_output_size - 1 times {
        if nn_output[i] > max_val {
            max_val = nn_output[i]
        }
        i = i + 1
    }
    
    return max_val * 100
}
