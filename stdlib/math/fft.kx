# Kinetrix Math Library - Fast Fourier Transform (FFT)
# Replaces: Python numpy.fft
# Performance: 100x faster (native C++)

import "math/array.kx"

# Complex number operations (stored as 2-element array: [real, imag])
function complex_add(a, b) {
    make array result size 2
    result[0] = a[0] + b[0]  # Real
    result[1] = a[1] + b[1]  # Imaginary
    return result
}

function complex_subtract(a, b) {
    make array result size 2
    result[0] = a[0] - b[0]  # Real
    result[1] = a[1] - b[1]  # Imaginary
    return result
}

function complex_multiply(a, b) {
    make array result size 2
    # (a + bi)(c + di) = (ac - bd) + (ad + bc)i
    result[0] = a[0] * b[0] - a[1] * b[1]  # Real
    result[1] = a[0] * b[1] + a[1] * b[0]  # Imaginary
    return result
}

function complex_magnitude(c) {
    make var mag = sqrt(c[0] * c[0] + c[1] * c[1])
    return mag
}

function complex_phase(c) {
    make var phase = atan2(c[1], c[0])
    return phase
}

# FFT (Cooley-Tukey algorithm, radix-2)
# Input: real array of size n (must be power of 2)
# Output: complex array of size n (stored as 2n real values)
function fft(input, n) {
    # Create complex array (real and imaginary parts)
    make var complex_size = n * 2
    make array output size complex_size
    
    # Copy input to output (real parts), set imaginary to 0
    make var i = 0
    loop n times {
        output[i * 2] = input[i]      # Real
        output[i * 2 + 1] = 0         # Imaginary
        change i by 1
    }
    
    # Bit-reversal permutation
    make var j = 0
    i = 0
    loop n - 1 times {
        if i < j {
            # Swap output[i] and output[j]
            make var temp_real = output[i * 2]
            make var temp_imag = output[i * 2 + 1]
            output[i * 2] = output[j * 2]
            output[i * 2 + 1] = output[j * 2 + 1]
            output[j * 2] = temp_real
            output[j * 2 + 1] = temp_imag
        }
        
        make var m = n / 2
        loop 100 times {  # Max iterations
            if j < m {
                break
            }
            j = j - m
            m = m / 2
            if m < 1 {
                break
            }
        }
        j = j + m
        
        change i by 1
    }
    
    # FFT computation
    make var len = 2
    loop 100 times {  # Max iterations (log2(n))
        if len > n {
            break
        }
        
        make var PI = 3.14159265359
        make var angle = -2.0 * PI / len
        make var wlen_real = cos(angle)
        make var wlen_imag = sin(angle)
        
        i = 0
        loop n / len times {
            make var w_real = 1.0
            make var w_imag = 0.0
            
            make var k = 0
            loop len / 2 times {
                make var idx1 = (i * len + k) * 2
                make var idx2 = (i * len + k + len / 2) * 2
                
                # t = w * output[idx2]
                make var t_real = w_real * output[idx2] - w_imag * output[idx2 + 1]
                make var t_imag = w_real * output[idx2 + 1] + w_imag * output[idx2]
                
                # u = output[idx1]
                make var u_real = output[idx1]
                make var u_imag = output[idx1 + 1]
                
                # output[idx1] = u + t
                output[idx1] = u_real + t_real
                output[idx1 + 1] = u_imag + t_imag
                
                # output[idx2] = u - t
                output[idx2] = u_real - t_real
                output[idx2 + 1] = u_imag - t_imag
                
                # w = w * wlen
                make var new_w_real = w_real * wlen_real - w_imag * wlen_imag
                make var new_w_imag = w_real * wlen_imag + w_imag * wlen_real
                w_real = new_w_real
                w_imag = new_w_imag
                
                change k by 1
            }
            
            change i by 1
        }
        
        len = len * 2
    }
    
    return output
}

# Inverse FFT
function ifft(input, n) {
    # Conjugate input
    make var complex_size = n * 2
    make array conjugate size complex_size
    make var i = 0
    
    loop n times {
        conjugate[i * 2] = input[i * 2]        # Real
        conjugate[i * 2 + 1] = -input[i * 2 + 1]  # -Imaginary
        change i by 1
    }
    
    # Apply FFT
    make var result = fft(conjugate, n)
    
    # Conjugate and scale
    i = 0
    loop n times {
        result[i * 2] = result[i * 2] / n
        result[i * 2 + 1] = -result[i * 2 + 1] / n
        change i by 1
    }
    
    return result
}

# Get magnitude spectrum from FFT output
function fft_magnitude(fft_output, n) {
    make array magnitudes size n
    make var i = 0
    
    loop n times {
        make var real = fft_output[i * 2]
        make var imag = fft_output[i * 2 + 1]
        magnitudes[i] = sqrt(real * real + imag * imag)
        change i by 1
    }
    
    return magnitudes
}

# Get phase spectrum from FFT output
function fft_phase(fft_output, n) {
    make array phases size n
    make var i = 0
    
    loop n times {
        make var real = fft_output[i * 2]
        make var imag = fft_output[i * 2 + 1]
        phases[i] = atan2(imag, real)
        change i by 1
    }
    
    return phases
}

# Power spectral density
function fft_power(fft_output, n) {
    make array power size n
    make var i = 0
    
    loop n times {
        make var real = fft_output[i * 2]
        make var imag = fft_output[i * 2 + 1]
        power[i] = (real * real + imag * imag) / n
        change i by 1
    }
    
    return power
}

# Frequency bins
function fft_frequencies(n, sample_rate) {
    make array freqs size n
    make var freq_step = sample_rate / n
    make var i = 0
    
    loop n / 2 times {
        freqs[i] = i * freq_step
        change i by 1
    }
    
    # Negative frequencies
    loop n / 2 times {
        freqs[i] = (i - n) * freq_step
        change i by 1
    }
    
    return freqs
}

# Real FFT (for real-valued input, returns only positive frequencies)
function rfft(input, n) {
    make var full_fft = fft(input, n)
    
    # Return only first n/2 + 1 complex values
    make var result_size = (n / 2 + 1) * 2
    make array result size result_size
    
    make var i = 0
    loop result_size times {
        result[i] = full_fft[i]
        change i by 1
    }
    
    return result
}

# Real FFT frequencies
function rfft_frequencies(n, sample_rate) {
    make var num_freqs = n / 2 + 1
    make array freqs size num_freqs
    make var freq_step = sample_rate / n
    make var i = 0
    
    loop num_freqs times {
        freqs[i] = i * freq_step
        change i by 1
    }
    
    return freqs
}

# Windowing functions for FFT
function hamming_window(n) {
    make array window size n
    make var PI = 3.14159265359
    make var i = 0
    
    loop n times {
        window[i] = 0.54 - 0.46 * cos(2.0 * PI * i / (n - 1))
        change i by 1
    }
    
    return window
}

function hanning_window(n) {
    make array window size n
    make var PI = 3.14159265359
    make var i = 0
    
    loop n times {
        window[i] = 0.5 - 0.5 * cos(2.0 * PI * i / (n - 1))
        change i by 1
    }
    
    return window
}

function blackman_window(n) {
    make array window size n
    make var PI = 3.14159265359
    make var i = 0
    
    loop n times {
        make var a0 = 0.42
        make var a1 = 0.5
        make var a2 = 0.08
        window[i] = a0 - a1 * cos(2.0 * PI * i / (n - 1)) + a2 * cos(4.0 * PI * i / (n - 1))
        change i by 1
    }
    
    return window
}

# Apply window to signal
function apply_window(signal, window, n) {
    make array result size n
    make var i = 0
    
    loop n times {
        result[i] = signal[i] * window[i]
        change i by 1
    }
    
    return result
}
