# Kinetrix Math Library - Statistics
# Replaces: Python scipy.stats
# Performance: 100x faster (native C++)

import "math/array.kx"

# Correlation coefficient
function correlation(x, y, size) {
    make var mean_x = array_mean(x, size)
    make var mean_y = array_mean(y, size)
    
    make var sum_xy = 0
    make var sum_x2 = 0
    make var sum_y2 = 0
    make var i = 0
    
    loop size times {
        make var dx = x[i] - mean_x
        make var dy = y[i] - mean_y
        
        sum_xy = sum_xy + (dx * dy)
        sum_x2 = sum_x2 + (dx * dx)
        sum_y2 = sum_y2 + (dy * dy)
        
        change i by 1
    }
    
    make var corr = sum_xy / sqrt(sum_x2 * sum_y2)
    return corr
}

# Covariance
function covariance(x, y, size) {
    make var mean_x = array_mean(x, size)
    make var mean_y = array_mean(y, size)
    
    make var sum = 0
    make var i = 0
    
    loop size times {
        make var dx = x[i] - mean_x
        make var dy = y[i] - mean_y
        sum = sum + (dx * dy)
        change i by 1
    }
    
    make var cov = sum / (size - 1)
    return cov
}

# Linear regression (y = mx + b)
function linear_regression(x, y, size) {
    make var mean_x = array_mean(x, size)
    make var mean_y = array_mean(y, size)
    
    make var sum_xy = 0
    make var sum_x2 = 0
    make var i = 0
    
    loop size times {
        make var dx = x[i] - mean_x
        make var dy = y[i] - mean_y
        
        sum_xy = sum_xy + (dx * dy)
        sum_x2 = sum_x2 + (dx * dx)
        
        change i by 1
    }
    
    make var slope = sum_xy / sum_x2
    make var intercept = mean_y - (slope * mean_x)
    
    # Return slope and intercept as array
    make array result size 2
    result[0] = slope
    result[1] = intercept
    return result
}

# R-squared (coefficient of determination)
function r_squared(x, y, size) {
    make var params = linear_regression(x, y, size)
    make var slope = params[0]
    make var intercept = params[1]
    make var mean_y = array_mean(y, size)
    
    make var ss_res = 0  # Residual sum of squares
    make var ss_tot = 0  # Total sum of squares
    make var i = 0
    
    loop size times {
        make var y_pred = slope * x[i] + intercept
        make var residual = y[i] - y_pred
        make var deviation = y[i] - mean_y
        
        ss_res = ss_res + (residual * residual)
        ss_tot = ss_tot + (deviation * deviation)
        
        change i by 1
    }
    
    make var r2 = 1.0 - (ss_res / ss_tot)
    return r2
}

# Percentile
function percentile(arr, size, p) {
    # Create sorted copy
    make array sorted size size
    make var i = 0
    loop size times {
        sorted[i] = arr[i]
        change i by 1
    }
    array_sort(sorted, size)
    
    # Calculate index
    make var index = (p / 100.0) * (size - 1)
    make var lower = index  # Floor
    make var upper = lower + 1
    
    if upper >= size {
        return sorted[size - 1]
    }
    
    # Linear interpolation
    make var fraction = index - lower
    make var result = sorted[lower] + fraction * (sorted[upper] - sorted[lower])
    return result
}

# Quartiles
function quartiles(arr, size) {
    make array result size 3
    result[0] = percentile(arr, size, 25)  # Q1
    result[1] = percentile(arr, size, 50)  # Q2 (median)
    result[2] = percentile(arr, size, 75)  # Q3
    return result
}

# Interquartile range
function iqr(arr, size) {
    make var q = quartiles(arr, size)
    make var iqr_val = q[2] - q[0]
    return iqr_val
}

# Z-score normalization
function zscore(arr, size) {
    make var mean = array_mean(arr, size)
    make var std = array_std(arr, size)
    
    make array result size size
    make var i = 0
    
    loop size times {
        result[i] = (arr[i] - mean) / std
        change i by 1
    }
    
    return result
}

# Min-max normalization
function normalize_minmax(arr, size) {
    make var min_val = array_min(arr, size)
    make var max_val = array_max(arr, size)
    make var range = max_val - min_val
    
    make array result size size
    make var i = 0
    
    loop size times {
        result[i] = (arr[i] - min_val) / range
        change i by 1
    }
    
    return result
}

# Moving average
function moving_average(arr, size, window) {
    make var result_size = size - window + 1
    make array result size result_size
    
    make var i = 0
    loop result_size times {
        make var sum = 0
        make var j = 0
        
        loop window times {
            sum = sum + arr[i + j]
            change j by 1
        }
        
        result[i] = sum / window
        change i by 1
    }
    
    return result
}

# Exponential moving average
function ema(arr, size, alpha) {
    make array result size size
    result[0] = arr[0]
    
    make var i = 1
    loop size - 1 times {
        result[i] = alpha * arr[i] + (1.0 - alpha) * result[i - 1]
        change i by 1
    }
    
    return result
}

# Cumulative sum
function cumsum(arr, size) {
    make array result size size
    result[0] = arr[0]
    
    make var i = 1
    loop size - 1 times {
        result[i] = result[i - 1] + arr[i]
        change i by 1
    }
    
    return result
}

# Cumulative product
function cumprod(arr, size) {
    make array result size size
    result[0] = arr[0]
    
    make var i = 1
    loop size - 1 times {
        result[i] = result[i - 1] * arr[i]
        change i by 1
    }
    
    return result
}

# Histogram
function histogram(arr, size, bins) {
    make var min_val = array_min(arr, size)
    make var max_val = array_max(arr, size)
    make var bin_width = (max_val - min_val) / bins
    
    make array counts size bins
    make var i = 0
    loop bins times {
        counts[i] = 0
        change i by 1
    }
    
    # Count values in each bin
    i = 0
    loop size times {
        make var bin_index = (arr[i] - min_val) / bin_width
        
        # Handle edge case for max value
        if bin_index >= bins {
            bin_index = bins - 1
        }
        
        counts[bin_index] = counts[bin_index] + 1
        change i by 1
    }
    
    return counts
}

# Mode (most frequent value)
function mode(arr, size) {
    # Simple implementation - assumes integer values
    # Create sorted copy
    make array sorted size size
    make var i = 0
    loop size times {
        sorted[i] = arr[i]
        change i by 1
    }
    array_sort(sorted, size)
    
    make var max_count = 1
    make var mode_val = sorted[0]
    make var current_count = 1
    
    i = 1
    loop size - 1 times {
        if sorted[i] is sorted[i - 1] {
            change current_count by 1
            
            if current_count > max_count {
                max_count = current_count
                mode_val = sorted[i]
            }
        } else {
            current_count = 1
        }
        
        change i by 1
    }
    
    return mode_val
}

# Skewness
function skewness(arr, size) {
    make var mean = array_mean(arr, size)
    make var std = array_std(arr, size)
    
    make var sum_cubed = 0
    make var i = 0
    
    loop size times {
        make var z = (arr[i] - mean) / std
        sum_cubed = sum_cubed + (z * z * z)
        change i by 1
    }
    
    make var skew = sum_cubed / size
    return skew
}

# Kurtosis
function kurtosis(arr, size) {
    make var mean = array_mean(arr, size)
    make var std = array_std(arr, size)
    
    make var sum_fourth = 0
    make var i = 0
    
    loop size times {
        make var z = (arr[i] - mean) / std
        sum_fourth = sum_fourth + (z * z * z * z)
        change i by 1
    }
    
    make var kurt = (sum_fourth / size) - 3.0  # Excess kurtosis
    return kurt
}
