# Kalman Filter - 2D Implementation
# For tracking position in 2D space (X, Y)

# State vector [x, y, vx, vy]
make var kalman_x = 0
make var kalman_y = 0
make var kalman_vx = 0
make var kalman_vy = 0

# Error covariance matrix (simplified)
make var kalman_px = 1
make var kalman_py = 1
make var kalman_pvx = 1
make var kalman_pvy = 1

# Noise parameters
make var kalman_q_2d = 0.01
make var kalman_r_2d = 0.1

# Initialize 2D Kalman filter
function kalman_2d_init(x, y, vx, vy) {
    kalman_x = x
    kalman_y = y
    kalman_vx = vx
    kalman_vy = vy
    kalman_px = 1
    kalman_py = 1
    kalman_pvx = 1
    kalman_pvy = 1
}

# Predict step (motion model)
function kalman_2d_predict(dt) {
    # State prediction: x = x + vx*dt
    kalman_x = kalman_x + kalman_vx * dt
    kalman_y = kalman_y + kalman_vy * dt
    
    # Covariance prediction
    kalman_px = kalman_px + kalman_pvx * dt * dt + kalman_q_2d
    kalman_py = kalman_py + kalman_pvy * dt * dt + kalman_q_2d
    kalman_pvx = kalman_pvx + kalman_q_2d
    kalman_pvy = kalman_pvy + kalman_q_2d
}

# Update step (measurement)
function kalman_2d_update(measured_x, measured_y) {
    # Kalman gain
    make var kx = kalman_px / (kalman_px + kalman_r_2d)
    make var ky = kalman_py / (kalman_py + kalman_r_2d)
    
    # State update
    kalman_x = kalman_x + kx * (measured_x - kalman_x)
    kalman_y = kalman_y + ky * (measured_y - kalman_y)
    
    # Covariance update
    kalman_px = (1 - kx) * kalman_px
    kalman_py = (1 - ky) * kalman_py
}

# Update with acceleration measurement
function kalman_2d_update_accel(ax, ay, dt) {
    # Update velocity from acceleration
    kalman_vx = kalman_vx + ax * dt
    kalman_vy = kalman_vy + ay * dt
}

# Get position
function kalman_2d_get_x() {
    return kalman_x
}

function kalman_2d_get_y() {
    return kalman_y
}

# Get velocity
function kalman_2d_get_vx() {
    return kalman_vx
}

function kalman_2d_get_vy() {
    return kalman_vy
}

# Get uncertainty
function kalman_2d_get_uncertainty() {
    return (kalman_px + kalman_py) / 2
}
