# Kinetrix Proprietary: Swarm Intelligence Coordinator
# TRADE SECRET - Multi-Robot Coordination System
#
# This demonstrates capabilities NO other robotics language has:
# - Distributed consensus algorithm
# - Swarm behavior emergence
# - Dynamic task allocation
# - Collision-free formation control
# - Self-healing network topology
#
# Use case: 10+ robots coordinating autonomously

# ============================================================================
# SWARM STATE - Each robot maintains this
# ============================================================================

# Robot identity
make var robot_id = 1
make var swarm_size = 10

# Position in swarm
make var my_x = 0
make var my_y = 0
make var my_heading = 0

# Neighbor information (up to 8 neighbors)
make array neighbor_x size 8
make array neighbor_y size 8
make array neighbor_dist size 8
make var neighbor_count = 0

# Swarm consensus variables
make var consensus_target_x = 0
make var consensus_target_y = 0
make var consensus_iterations = 0

# Task allocation
make var my_task = 0
make var task_priority = 0

# Formation control
make var formation_type = 0
make var formation_spacing = 50

# ============================================================================
# PROPRIETARY: Distributed Consensus Algorithm (Raft-inspired)
# ============================================================================

def broadcast_position {
    # Broadcast my position to swarm via I2C bus
    i2c begin
    
    # Each robot has unique I2C address (0x10 + robot_id)
    make var broadcast_addr = 0x10
    
    repeat swarm_size {
        i2c start broadcast_addr
        i2c send my_x
        i2c send my_y
        i2c send my_heading
        i2c stop
        
        change broadcast_addr by 1
    }
}

def receive_neighbor_data {
    set neighbor_count to 0
    
    # Listen for broadcasts from other robots
    make var addr = 0x10
    
    repeat swarm_size {
        if addr is robot_id {
            # Skip self
            change addr by 1
        }
        
        # Read neighbor position
        make var nx = read i2c addr
        make var ny = read i2c addr
        
        # Calculate distance
        make var dx = nx - my_x
        make var dy = ny - my_y
        make var dist = sqrt(dx * dx + dy * dy)
        
        # Only track nearby neighbors (within 200 units)
        if dist < 200 {
            set index neighbor_x at neighbor_count to nx
            set index neighbor_y at neighbor_count to ny
            set index neighbor_dist at neighbor_count to dist
            
            change neighbor_count by 1
        }
        
        change addr by 1
    }
}

def consensus_vote {
    # Average neighbor targets (distributed consensus)
    make var sum_x = my_x
    make var sum_y = my_y
    make var count = 1
    
    make var i = 0
    repeat neighbor_count {
        make var nx = index neighbor_x at i
        make var ny = index neighbor_y at i
        
        set sum_x to sum_x + nx
        set sum_y to sum_y + ny
        change count by 1
        change i by 1
    }
    
    # Consensus = average of all positions
    set consensus_target_x to sum_x / count
    set consensus_target_y to sum_y / count
    
    change consensus_iterations by 1
}

# ============================================================================
# PROPRIETARY: Emergent Swarm Behaviors
# ============================================================================

def behavior_cohesion {
    # Move toward center of mass of neighbors
    make var center_x = 0
    make var center_y = 0
    
    if neighbor_count > 0 {
        make var i = 0
        repeat neighbor_count {
            set center_x to center_x + index neighbor_x at i
            set center_y to center_y + index neighbor_y at i
            change i by 1
        }
        
        set center_x to center_x / neighbor_count
        set center_y to center_y / neighbor_count
    }
    
    # Return vector toward center
    make var cohesion_x = center_x - my_x
    make var cohesion_y = center_y - my_y
    
    return cohesion_x
}

def behavior_separation {
    # Avoid collisions with neighbors
    make var repel_x = 0
    make var repel_y = 0
    
    make var i = 0
    repeat neighbor_count {
        make var dist = index neighbor_dist at i
        
        # Strong repulsion if too close
        if dist < formation_spacing {
            make var nx = index neighbor_x at i
            make var ny = index neighbor_y at i
            
            make var dx = my_x - nx
            make var dy = my_y - ny
            
            # Inverse square law repulsion
            make var force = 1000 / (dist * dist + 1)
            
            set repel_x to repel_x + force * dx
            set repel_y to repel_y + force * dy
        }
        
        change i by 1
    }
    
    return repel_x
}

def behavior_alignment {
    # Match velocity/heading of neighbors
    make var avg_heading = my_heading
    make var count = 1
    
    # In real implementation, neighbors would broadcast heading
    # For now, compute heading from position changes
    
    return avg_heading
}

def compute_swarm_force {
    # Blend three behaviors (Reynolds' Boids algorithm)
    make var cohesion_x = behavior_cohesion()
    make var cohesion_y = 0
    
    make var separation_x = behavior_separation()
    make var separation_y = 0
    
    make var alignment = behavior_alignment()
    
    # Weighted combination
    make var force_x = 0.3 * cohesion_x + 0.5 * separation_x
    make var force_y = 0.3 * cohesion_y + 0.5 * separation_y
    
    return force_x
}

# ============================================================================
# PROPRIETARY: Dynamic Task Allocation
# ============================================================================

def allocate_tasks {
    # Market-based task allocation
    # Tasks: 0=explore, 1=guard, 2=transport, 3=recharge
    
    make var battery_level = read analog pin 0
    
    # If low battery, prioritize recharge
    if battery_level < 50 {
        set my_task to 3
        set task_priority to 100
        return 3
    }
    
    # Count how many neighbors doing each task
    make var explorers = 0
    make var guards = 0
    make var transporters = 0
    
    # In real implementation, neighbors broadcast their tasks
    # For now, use simple heuristic
    
    # Balance tasks across swarm
    if explorers < 3 {
        set my_task to 0
        set task_priority to 50
    }
    
    if guards < 2 {
        set my_task to 1
        set task_priority to 70
    }
    
    return my_task
}

# ============================================================================
# PROPRIETARY: Formation Control
# ============================================================================

def formation_line {
    # Arrange robots in a line
    make var target_x = robot_id * formation_spacing
    make var target_y = 0
    
    return target_x
}

def formation_circle {
    # Arrange robots in a circle
    make var angle = robot_id * 360 / swarm_size
    make var radius = formation_spacing * swarm_size / 6.28
    
    make var target_x = radius * cos(angle)
    make var target_y = radius * sin(angle)
    
    return target_x
}

def formation_grid {
    # Arrange robots in a grid
    make var cols = sqrt(swarm_size)
    make var row = robot_id / cols
    make var col = robot_id - row * cols
    
    make var target_x = col * formation_spacing
    make var target_y = row * formation_spacing
    
    return target_x
}

def execute_formation {
    make var target_x = 0
    make var target_y = 0
    
    if formation_type is 0 {
        set target_x to formation_line()
    }
    
    if formation_type is 1 {
        set target_x to formation_circle()
    }
    
    if formation_type is 2 {
        set target_x to formation_grid()
    }
    
    # Move toward formation position
    make var error_x = target_x - my_x
    make var error_y = target_y - my_y
    
    return error_x
}

# ============================================================================
# MAIN SWARM COORDINATOR
# ============================================================================

program {
    # Initialize robot
    set robot_id to read analog pin 1
    
    i2c begin
    
    # Set initial formation
    set formation_type to 1
    set formation_spacing to 50
    
    # Main swarm loop (50Hz)
    loop forever {
        # 1. Broadcast my state
        broadcast_position()
        
        # 2. Receive neighbor data
        receive_neighbor_data()
        
        # 3. Run consensus algorithm
        consensus_vote()
        
        # 4. Allocate tasks dynamically
        allocate_tasks()
        
        # 5. Compute swarm behaviors
        make var swarm_x = compute_swarm_force()
        make var swarm_y = 0
        
        # 6. Execute formation
        make var formation_x = execute_formation()
        make var formation_y = 0
        
        # 7. Blend behaviors based on task
        make var final_x = 0
        make var final_y = 0
        
        if my_task is 0 {
            # Explore: prioritize swarm behavior
            set final_x to 0.8 * swarm_x + 0.2 * formation_x
        }
        
        if my_task is 1 {
            # Guard: prioritize formation
            set final_x to 0.2 * swarm_x + 0.8 * formation_x
        }
        
        # 8. Convert to motor commands
        make var left_motor = final_y + final_x
        make var right_motor = final_y - final_x
        
        # Clamp
        if left_motor > 255 {
            set left_motor to 255
        }
        if right_motor > 255 {
            set right_motor to 255
        }
        
        # 9. Apply motors
        set pin 3 to left_motor
        set pin 5 to right_motor
        
        # 10. Status LED (blink = alive)
        if consensus_iterations > 10 {
            turn on pin 13
            set consensus_iterations to 0
        }
        turn off pin 13
        
        wait 20
    }
}
